# Custom Equality in Python OOP

## 1. Default Equality Behavior

* By default, `==` compares **object identities** (memory addresses), not values.
* Two different objects with the same attributes will not be equal unless `__eq__` is overridden.

**Example:**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("Alice", 30)
p2 = Person("Alice", 30)

print(p1 == p2)  # False (different objects, same data)
```



## 2. Overriding `__eq__`

* Define `__eq__(self, other)` to specify how two objects are considered equal.
* Must return a boolean (`True` or `False`).
* Should handle the case where `other` is not the same type.

**Example:**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        if not isinstance(other, Person):
            return NotImplemented
        return self.name == other.name and self.age == other.age

p1 = Person("Alice", 30)
p2 = Person("Alice", 30)
p3 = Person("Bob", 25)

print(p1 == p2)  # True (same data)
print(p1 == p3)  # False (different data)
```



## 3. Best Practices

1. **Type-check with `isinstance`:**
   Prevents comparing unrelated objects. Return `NotImplemented` if the types differ.

2. **Consistency with `__hash__`:**
   If you override `__eq__`, and your objects will be used in sets or as dictionary keys, you should also override `__hash__`.

3. **Reflexivity, Symmetry, Transitivity:**
   Ensure your equality is logically consistent:

   * Reflexive: `a == a` is `True`.
   * Symmetric: `a == b` implies `b == a`.
   * Transitive: if `a == b` and `b == c`, then `a == c`.

## 4. Example with `__hash__`

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        if not isinstance(other, Person):
            return NotImplemented
        return (self.name, self.age) == (other.name, other.age)

    def __hash__(self):
        return hash((self.name, self.age))

# usage in a set
p1 = Person("Alice", 30)
p2 = Person("Alice", 30)
people = {p1, p2}

print(len(people))  # 1, because p1 == p2 and they hash to the same value
```


## 5. Summary

* `==` compares object identity by default.
* Override `__eq__` to define equality by attribute values.
* Return `NotImplemented` for incompatible types.
* If objects will be used in sets or dict keys, implement `__hash__` consistently.
