
# Guide to Polymorphism in Python OOP

## 1. What is Polymorphism?

* Polymorphism means *“many forms”*.
* In OOP, it allows different classes to define methods with the same name, but possibly with different behaviors.
* It enables writing code that can work with objects of different classes through a common interface.



## 2. Polymorphism Through Method Overriding

When a subclass provides its own version of a method from the parent class.

**Example:**

```python
class Animal:
    def speak(self):
        return "Some sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

animals = [Dog(), Cat(), Animal()]

for a in animals:
    print(a.speak())
```

Output:

```
Woof!
Meow!
Some sound
```

Here, `speak()` is polymorphic—each class responds differently, but the method call is the same.



## 3. Polymorphism Through Duck Typing

Python emphasizes *behavior over type*.
If an object implements the required method, it can be used, regardless of its class.

**Example:**

```python
class Duck:
    def quack(self):
        return "Quack!"

class Person:
    def quack(self):
        return "I'm pretending to be a duck!"

def make_it_quack(thing):
    print(thing.quack())

make_it_quack(Duck())
make_it_quack(Person())
```

Output:

```
Quack!
I'm pretending to be a duck!
```

This is “duck typing”: *“If it quacks like a duck, it’s a duck.”*


## 4. Benefits of Polymorphism

* **Code reusability:** Write functions that work with many types.
* **Extensibility:** Add new classes without changing existing code.
* **Flexibility:** Swap objects without rewriting client code.

# Liskov Substitution Principle (LSP)

## 5. What is LSP?

* Proposed by Barbara Liskov (1987).
* States:
  **“Objects of a superclass should be replaceable with objects of a subclass without breaking the correctness of the program.”**

In simpler words:

* If `B` is a subclass of `A`, then anywhere you use an `A`, you should be able to use `B` without unexpected behavior.


## 6. LSP Example (Good)

```python
class Bird:
    def fly(self):
        return "Flying high!"

class Sparrow(Bird):
    def fly(self):
        return "Sparrow flying low!"

def let_bird_fly(bird: Bird):
    print(bird.fly())

let_bird_fly(Bird())     # Flying high!
let_bird_fly(Sparrow())  # Sparrow flying low!
```

Here, `Sparrow` substitutes `Bird` correctly. The program still makes sense.


## 7. LSP Violation Example (Bad)

```python
class Bird:
    def fly(self):
        return "Flying high!"

class Ostrich(Bird):  # Ostrich can't fly!
    def fly(self):
        raise NotImplementedError("Ostriches can't fly")

def let_bird_fly(bird: Bird):
    print(bird.fly())

let_bird_fly(Ostrich())  # Runtime error
```

This violates LSP because an `Ostrich` is a `Bird`, but it breaks the expected behavior (`fly()` should always work for a `Bird`).


## 8. Connecting Polymorphism and LSP

* **Polymorphism**: Allows subclasses to provide their own implementation of methods.
* **LSP**: Ensures that polymorphism does not break expectations.
* Together:

  * Polymorphism gives flexibility.
  * LSP ensures safety and correctness.

Think of it this way:
Polymorphism says *“Subclasses can change behavior.”*
LSP adds *“…but not in a way that breaks the parent’s contract.”*


## 9. Summary

* Polymorphism: Same interface, different implementations.
* LSP: Subtypes must behave consistently with their base types.
* They are connected because polymorphism is powerful, but without LSP, it can introduce errors.
* Always design subclasses so that they can replace their parent classes without surprising the program.
