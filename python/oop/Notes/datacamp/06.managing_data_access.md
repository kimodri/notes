# Managing Access in Python (Encapsulation)

Encapsulation is about controlling access to the internal data of a class. Python doesn‚Äôt enforce strict access modifiers (`private`, `protected`) like Java or C++; instead, it uses **conventions and properties** to achieve the same effect.



## 1. Naming Conventions for Attributes

* **Public (default)**:

  ```python
  self.attr
  ```

  Anyone can read/write it.

* **Protected (convention)**:

  ```python
  self._attr
  ```

  ‚ÄúFor internal use.‚Äù Developers are warned not to touch it directly.

* **Private (name mangling)**:

  ```python
  self.__attr
  ```

  Python internally renames it to `_ClassName__attr`. This reduces accidental access but doesn‚Äôt make it impossible.

Example:

```python
class Demo:
    def __init__(self):
        self.public = "public"
        self._protected = "protected"
        self.__private = "private"

d = Demo()
print(d.public)       # OK
print(d._protected)   # Possible, but discouraged
print(d._Demo__private)  # Access via name mangling
```


## 2. Properties for Controlled Access

The `@property` mechanism allows you to **control how attributes are read, written, or deleted**.

There are two parts to defining a property:

- first, define an "internal" attribute that will contain the data;
- then, define a `@property-decorated` method whose name is the property name, and that returns the internal attribute storing the data.

If you'd also like to define a custom setter method, there's an additional step:

define another method whose name is exactly the property name (again), and decorate it with `@prop_name.setter` where `prop_name` is the name of the property. The method should take two arguments -- `self` (as always), and the value that's being assigned to the property.

### Basic Pattern

```python
class Example:
    def __init__(self, value):
        self._value = value

    @property
    def value(self):
        """Getter: read-only access unless setter is defined."""
        return self._value

    @value.setter
    def value(self, new_value):
        """Setter: runs when obj.value = new_value."""
        if new_value < 0:
            raise ValueError("Value must be non-negative")
        self._value = new_value

    @value.deleter
    def value(self):
        """Deleter: runs when del obj.value is called."""
        print("Deleting value")
        del self._value
```



## 3. Read-Only Properties (like `.shape`)

If you **omit the setter**, the property becomes **read-only**, just like `.shape` in NumPy arrays or `.name` in many objects.

```python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def area(self):
        """Read-only: compute on demand."""
        return self._width * self._height

rect = Rectangle(3, 4)
print(rect.area)    # 12
# rect.area = 20   -> AttributeError: can't set attribute
```

üëâ Tip: Use this pattern when the value should always be derived or fixed (not assigned).



## 4. `@<attr>.getter` and `@<attr>.deleter`

If you define a property first, you can **extend it later** with `.getter`, `.setter`, `.deleter` instead of putting them all at once.

```python
class Person:
    def __init__(self, name):
        self._name = name

    # Define base property
    @property
    def name(self):
        return self._name

    # Add setter
    @name.setter
    def name(self, new_name):
        if not new_name.strip():
            raise ValueError("Name cannot be empty")
        self._name = new_name

    # Add deleter
    @name.deleter
    def name(self):
        print("Deleting name")
        del self._name
```

This works the same way as defining all inside the class body under the first `@property`.


## 5. When to Use What

* Use **public attributes** when no restrictions are needed.
* Use **protected (`_attr`)** when you want to discourage direct access.
* Use **private (`__attr`)** for internal data you don‚Äôt want easily exposed.
* Use **`@property` without setter** for **read-only attributes** (e.g., `.shape`).
* Use **`@property` + setter** for **validation and controlled assignment**.
* Use **`@property` + deleter** only when you need to handle deletion explicitly.

