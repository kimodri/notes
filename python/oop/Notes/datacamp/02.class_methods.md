# Class Methods in Python OOP

## 1. What is a Class Method?

* A **class method** is a method that is bound to the class, not the instance.
* It receives the class (`cls`) as its first argument instead of the instance (`self`).
* Defined using the `@classmethod` decorator.
* Can access and modify **class data**, but not instance-specific data (unless an instance is created inside).

---

## 2. Syntax

```python
class MyClass:
    class_data = "Shared"

    @classmethod
    def my_class_method(cls):
        return f"Class data is: {cls.class_data}"
```

---

## 3. Difference Between `classmethod`, `staticmethod`, and `instance method`

| Method Type     | First Parameter | Access to Class Data        | Access to Instance Data | Common Use                                 |
| --------------- | --------------- | --------------------------- | ----------------------- | ------------------------------------------ |
| Instance Method | `self`          | Yes (via `self.__class__`)  | Yes                     | Object behavior, per-instance logic        |
| Class Method    | `cls`           | Yes                         | No                      | Alternative constructors, class-wide logic |
| Static Method   | None            | No (unless manually passed) | No                      | Utility functions                          |

---

## 4. Class Method as Alternative Constructor

An **alternative constructor** is a way to create objects from different input formats or data sources, while still returning an instance of the class.

This is a common and recommended use of `@classmethod`.

**Example 1: Creating from a string**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_string(cls, data_str):
        name, age = data_str.split("-")
        return cls(name, int(age))  # calls the normal constructor

# normal constructor
p1 = Person("Alice", 30)

# alternative constructor
p2 = Person.from_string("Bob-25")

print(p1.name, p1.age)  # Alice 30
print(p2.name, p2.age)  # Bob 25
```

**Example 2: Creating from a dictionary**

```python
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

    @classmethod
    def from_dict(cls, data):
        return cls(data["title"], data["author"])

book_data = {"title": "1984", "author": "George Orwell"}

b1 = Book.from_dict(book_data)
print(b1.title, b1.author)  # 1984 George Orwell
```

---

## 5. Why Use Class Methods for Alternative Constructors?

* Improves readability by giving meaningful names to different construction patterns (`from_string`, `from_dict`, `from_json`, etc.).
* Keeps logic encapsulated inside the class instead of external helper functions.
* Works correctly with inheritance: subclasses calling the class method will return instances of the subclass, not the parent.

---

## 6. Summary

* Use `@classmethod` when the method needs to work with the class itself, not a single instance.
* Alternative constructors are the most common use case.
* They make code more organized and allow flexible object creation from multiple input formats.

